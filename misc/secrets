#!/usr/bin/env bash
set -ueo pipefail

: "${FORCE_PUSH:=0}"
: "${SECRETS_REPO_URL:=git@git.unboiled.info:monk/nix-secrets}"
: "${SECRETS_REPO_CACHE:=/tmp/.secrets-cache}"

if ! command -v git-crypt >/dev/null; then  # git wants it in PATH for `filter`
    gitcrypt=$(nix build --print-out-paths --no-link 'nixpkgs#git-crypt')
    PATH=$PATH:$gitcrypt/bin
fi

check_status() {
    local status
    status=$(git-crypt status -u \
           | grep -vFx 'not encrypted: .git-crypt/.gitattributes' \
           | grep -vFx 'not encrypted: .gitattributes' \
           | grep -vx 'not encrypted: .git-crypt/keys/default/0/.*.gpg' \
           || true)
    [[ -z "$status" ]] || \
        { echo 1>&2 "something's wrong with the repository"; exit 1; }
}

clone() {
     git clone -q --reference-if-able "$SECRETS_REPO_CACHE" \
               $SECRETS_REPO_URL "$secrets_tmp_checkout"
     if [[ ! -d $SECRETS_REPO_CACHE ]]; then
          git clone -q --bare "$secrets_tmp_checkout" "$SECRETS_REPO_CACHE"
     fi
     pushd "$secrets_tmp_checkout" > /dev/null
     check_status
     popd > /dev/null
     echo "$secrets_tmp_checkout"
}

sanity_check_host() { local f=$1
    [[ -d "/etc/nixos/hosts/$f" ]] || \
        { echo 1>&2 "no such host '$f', aborting!"; exit 1; }
    [[ -e "/etc/nixos/hosts/$f/disko.nix" ]] || \
        { echo 1>&2 "'host $f' is not new enough, aborting!"; exit 1; }
}

find_hosts() {
    local f
    find . -maxdepth 1 | while IFS= read -r f; do
        if [[ "$f" =~ ^./(.*) ]]; then
            f=${BASH_REMATCH[1]}
        fi
        if [[ "$f" == '.' || "$f" =~ .git ]]; then
            continue
        fi
        [[ -d "$f" ]] || \
            { echo 1>&2 "top-level file '$f' found, aborting!"; exit 1; }
        sanity_check_host "$f"
        echo "$f"
    done
}

inject_secrets_to_host() { host=$1
    sanity_check_host "$host"
    rsync -r --delete-after --perms --chown=0:0 --chmod=400 \
          "./$host/" "root@$host:/mnt/persist/secrets"
}

commit() { local COMMIT_MSG=$1
    if [[ -n "$(git diff HEAD)" ]] \
    || [[ -n "$(git diff --staged HEAD)" ]]; then
        : "${COMMIT_MSG:=}"
        if [[ -n "$COMMIT_MSG" ]]; then
            git commit -m "$COMMIT_MSG"
        else
            git commit
        fi
    else
        echo 1>&2 'not seeing anything to commit'
    fi
    check_status
}

### building blocks of subcommands

clone_unlock() {
    echo 1>&2 -n 'cloning...'
    secrets_workdir=$(clone)
    pushd "$secrets_workdir" > /dev/null
    echo 1>&2 ' unlock!'
    git-crypt unlock
    check_status
    popd > /dev/null
    echo "$secrets_workdir"
}

push_to_repo() {
    check_status
    git-crypt lock
    echo 1>&2 'pushing repository changes...'
    git push -q
    echo 1>&2 'done, changes pushed to repository'
}

push_to_repo_if_changed() {
    if [[ -n "$(git status --porcelain)" ]] \
    || [[ -n "$(git diff origin/HEAD)" ]] \
    || [[ -n "$(git log --oneline origin/HEAD..HEAD)" ]]; then
        push_to_repo
    else
        echo 1>&2 'done, no repository changes'
    fi
}

### subcommands

subcmd_init() {
    : "${SECRETS_REPO_URL:=$1}"
    echo 1>&2 "cloning $SECRETS_REPO_URL..."
    secrets_workdir=$(clone)
    cd "$secrets_workdir"
    echo 1>&2 "checking that it's empty..."
    [[ -z "$(git rev-list -n 1 --all)" ]] || \
        { echo 1>&2 "repository doesn't look empty!"; exit 1; }
    git-crypt init
    git-crypt add-gpg-user monk@unboiled.info
    echo '** filter=git-crypt diff=git-crypt' > .gitattributes
    echo '.gitattributes !filter !diff' >> .gitattributes
    git add .gitattributes
    git commit --amend -m 'initial commit'
    push_to_repo
    echo 1>&2 'initialized'
}

subcmd_exec() {
    cd "$(clone_unlock)"

    # execute the passed command
    if [[ -n "$*" ]]; then
        "$@"
        : "${COMMIT_MSG:=$*}"
    else
        (export PS1='@secrets$ ' HISTSIZE=0; bash --norc)
    fi
    git add ./*

    find_hosts | while IFS= read -r host; do
        if [[ -n "$(git status --porcelain "$host")" ]] \
        || [[ -n "$(git diff origin/HEAD "$host")" ]] \
        || [[ -n "$(git log --oneline origin/HEAD..HEAD "$host")" ]] \
        || [[ "$FORCE_PUSH" == 1 ]]; then
            echo 1>&2 "injecting secrets to host: $host..."
            inject_secrets_to_host "$host"
        else
            echo 1>&2 "skipping: $host"
        fi
    done

    commit "${COMMIT_MSG:-}"

    push_to_repo_if_changed
}

subcmd_inject() {
    workdir=$(clone_unlock)
    cd "$workdir"
    for host in "$@"; do
        echo 1>&2 "injecting secrets to host: $host..."
        inject_secrets_to_host "$host"
    done
}

subcmd_inject_to_dir() { local host=$1 tgt_dir=$2
    workdir=$(clone_unlock)
    rsync -r --perms --chmod=D700,F400 "$workdir/$host/" "$tgt_dir"
}

subcmd_slurp() {
    workdir=$(clone_unlock)
    cd "$workdir"
    for host in "$@"; do
        [[ "$(dirname "$(realpath "./$host")")" == "$workdir" ]]
        sanity_check_host "$host"
        mkdir -p "./$host"
        echo 1>&2 "slurping secrets from host: $host..."
        rsync -r --delete-after --perms --chmod=D700,F400 \
              "root@$host:/mnt/persist/secrets/" "./$host"
        git add "./$host"
    done
    commit "import from $*"
    push_to_repo_if_changed
}

### subcommands dispatcher

# doesn't work in a function
secrets_tmp_checkout=$(mktemp -d); trap 'rm -rf $secrets_tmp_checkout' EXIT

subcommand=$1; shift
case "$subcommand" in
    init)
        subcmd_init "$@"
        ;;
    exec)
        subcmd_exec "$@"
        ;;
    edit)
        COMMIT_MSG="edit $*" subcmd_exec "$EDITOR" "$@"
        ;;
    vi)
        COMMIT_MSG="edit $*" subcmd_exec vi "$@"
        ;;
    inject)
        subcmd_inject "$@"
        ;;
    inject-to-dir)
        subcmd_inject_to_dir "$@"
        ;;
    slurp)
        subcmd_slurp "$@"
        ;;
    *)
        echo 1>&2 "subcommand '$subcommand' does not exist!"; exit 1;
        ;;
esac
