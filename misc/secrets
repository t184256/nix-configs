#!/usr/bin/env bash
set -ueo pipefail

: "${FORCE_INJECT:=0}"
: "${SECRETS_REPO_URL:=git@git.unboiled.info:monk/nix-secrets}"
: "${SECRETS_REPO_CACHE:=/tmp/.secrets-cache}"

if ! command -v git-crypt >/dev/null; then  # git wants it in PATH for `filter`
    gitcrypt=$(nix build --print-out-paths --no-link 'nixpkgs#git-crypt')
    PATH=$PATH:$gitcrypt/bin
fi

check_status() {
    local status
    status=$(git-crypt status -u \
           | grep -vFx 'not encrypted: .git-crypt/.gitattributes' \
           | grep -vFx 'not encrypted: .gitattributes' \
           | grep -vx 'not encrypted: .git-crypt/keys/default/0/.*.gpg' \
           || true)
    [[ -z "$status" ]] || \
        { echo 1>&2 "something's wrong with the repository"; exit 1; }
}

clone() {
    if [[ ! -d "$SECRETS_REPO_CACHE" ]]; then
         git clone -q --bare "$SECRETS_REPO_URL" "$SECRETS_REPO_CACHE"
    fi
    git clone -q --reference-if-able "$SECRETS_REPO_CACHE" \
              "$SECRETS_REPO_URL" "$secrets_tmp_checkout"
    pushd "$secrets_tmp_checkout" > /dev/null
    check_status
    popd > /dev/null
    echo "$secrets_tmp_checkout"
}

sanity_check_host() { local f=$1
    [[ -d "/etc/nixos/hosts/$f" ]] || \
        { echo 1>&2 "no such host '$f', aborting!"; exit 1; }
    [[ -e "/etc/nixos/hosts/$f/disko.nix" ]] || \
        { echo 1>&2 "'host $f' is not new enough, aborting!"; exit 1; }
}

find_hosts() {
    local f
    find . -maxdepth 1 | while IFS= read -r f; do
        if [[ "$f" =~ ^./(.*) ]]; then
            f=${BASH_REMATCH[1]}
        fi
        if [[ "$f" == '.' || "$f" =~ .git ]]; then
            continue
        fi
        [[ -d "$f" ]] || \
            { echo 1>&2 "top-level file '$f' found, aborting!"; exit 1; }
        sanity_check_host "$f"
        echo "$f"
    done
}

inject_secrets_to_host() { host=$1
    sanity_check_host "$host"
    rsync -r --delete-after --perms --chown=0:0 --chmod=400 \
          "./$host/" "root@$host:/mnt/persist/secrets"
}

commit() { local COMMIT_MSG=$1
    [[ -e .git-crypt ]]
    if [[ -n "$(git diff HEAD)" ]] \
    || [[ -n "$(git diff --staged HEAD)" ]]; then
        : "${COMMIT_MSG:=}"
        if [[ -n "$COMMIT_MSG" ]]; then
            git commit -m "$COMMIT_MSG"
        else
            git commit
        fi
    else
        echo 1>&2 'not seeing anything to commit'
    fi
    check_status
}

### building blocks of subcommands

clone_unlock() {
    echo 1>&2 -n 'cloning...'
    secrets_workdir=$(clone)
    pushd "$secrets_workdir" > /dev/null
    echo 1>&2 -n ' unlock!'
    git-crypt unlock
    echo 1>&2
    check_status
    popd > /dev/null
    echo "$secrets_workdir"
}

push_to_repo() {
    check_status
    git-crypt lock
    echo 1>&2 'pushing repository changes...'
    git push -q
    echo 1>&2 'done, changes pushed to repository'
}

push_to_repo_if_changed() {
    if [[ -n "$(git status --porcelain)" ]] \
    || [[ -n "$(git diff origin/HEAD)" ]] \
    || [[ -n "$(git log --oneline origin/HEAD..HEAD)" ]]; then
        push_to_repo
    else
        echo 1>&2 'done, no repository changes'
    fi
}

inject_commit_and_push_changes() {
    [[ -e .git-crypt ]]
    git add ./*

    local skipped=''
    find_hosts | while IFS= read -r host; do
        if [[ -n "$(git status --porcelain "$host")" ]] \
        || [[ -n "$(git diff origin/HEAD "$host")" ]] \
        || [[ -n "$(git log --oneline origin/HEAD..HEAD "$host")" ]] \
        || [[ "$FORCE_INJECT" == 1 ]]; then
            echo 1>&2 "injecting secrets to host: $host..."
            inject_secrets_to_host "$host"
        else
            skipped+=" $host"
        fi
        [[ -z "$skipped" ]] || echo 1>&2 "skipped injection to:$skipped"
    done

    commit "${COMMIT_MSG:-}"

    push_to_repo_if_changed
}

### subcommands

subcmd_init() {
    : "${SECRETS_REPO_URL:=$1}"
    echo 1>&2 "cloning $SECRETS_REPO_URL..."
    secrets_workdir=$(clone)
    cd "$secrets_workdir"
    echo 1>&2 "checking that it's empty..."
    [[ -z "$(git rev-list -n 1 --all)" ]] || \
        { echo 1>&2 "repository doesn't look empty!"; exit 1; }
    git-crypt init
    git-crypt add-gpg-user monk@unboiled.info
    echo '** filter=git-crypt diff=git-crypt' > .gitattributes
    echo '.gitattributes !filter !diff' >> .gitattributes
    git add .gitattributes
    git commit --amend -m 'initial commit'
    push_to_repo
    echo 1>&2 'initialized'
}

subcmd_exec() {
    cd "$(clone_unlock)"

    # execute the passed command
    if [[ -n "$*" ]]; then
        "$@"
        : "${COMMIT_MSG:=$*}"
    else
        (export PS1='@secrets$ ' HISTSIZE=0; bash --norc)
    fi
    inject_commit_and_push_changes "${COMMIT_MSG:-}"
}

subcmd_generate() { local host=$1 type=$2
    workdir=$(clone_unlock)
    if ! command -v dasel >/dev/null; then
        dasel=$(nix build --print-out-paths --no-link 'nixpkgs#dasel')
        PATH=$PATH:$dasel/bin
    fi
    case "$type" in
        sshd)
            COMMIT_MSG="generate ssh key for $host"
            command -v ssh-keygen 2>/dev/null && \
                sshkeygen=ssh-keygen ||
                sshkeygen=$(nix build --print-out-paths --no-link \
                                      'nixpkgs#openssh')/bin/ssh-keygen
            mkdir -p "$workdir/$host/sshd"
            $sshkeygen -t ed25519 -N '' -C "$host" \
                       -f "$workdir/$host/sshd/ed25519"
            grep -qF 'OPENSSH PRIVATE KEY' "$workdir/$host/sshd/ed25519"
            grep -q '^ssh-ed25519' "$workdir/$host/sshd/ed25519.pub"
            dasel put -f misc/pubkeys/sshd.toml -t string \
                "$host" -v "$(cat "$workdir/$host/sshd/ed25519.pub")"
            rm "$workdir/$host/sshd/ed25519.pub"
        ;;
        login)
            local user=$3
            COMMIT_MSG="generate login password for $user@$host"
            read -rsp "enter login password for $user@$host: " PASSWORD
            echo
            read -rsp "enter login password for $user@$host, again: " PASSWORD2
            echo
            [[ "$PASSWORD" == "$PASSWORD2" ]] ||
                { echo 1>&2 "passwords did not match!"; exit 1; }
            mkdir -p "$workdir/$host/login"
            mkpasswd -s <<<"$PASSWORD" > "$workdir/$host/login/$user"
            grep -qF '$y$' "$workdir/$host/login/$user"
        ;;
        *)
            echo 1>&2 "wait, how does one generate '$2'?"; exit 1;
        ;;
    esac
    cd "$workdir"
    inject_commit_and_push_changes "${COMMIT_MSG:-}"
}

subcmd_inject() {
    workdir=$(clone_unlock)
    cd "$workdir"
    for host in "$@"; do
        echo 1>&2 "injecting secrets to host: $host..."
        inject_secrets_to_host "$host"
    done
}

subcmd_inject_to_dir() { local host=$1 tgt_dir=$2
    workdir=$(clone_unlock)
    rsync -r --perms --chmod=D700,F400 "$workdir/$host/" "$tgt_dir"
}

subcmd_slurp() {
    workdir=$(clone_unlock)
    cd "$workdir"
    for host in "$@"; do
        [[ "$(dirname "$(realpath "./$host")")" == "$workdir" ]]
        sanity_check_host "$host"
        mkdir -p "./$host"
        echo 1>&2 "slurping secrets from host: $host..."
        rsync -r --delete-after --perms --chmod=D700,F400 \
              "root@$host:/mnt/persist/secrets/" "./$host"
        git add "./$host"
    done
    commit "import from $*"
    push_to_repo_if_changed
}

### subcommands dispatcher

# doesn't work in a function
secrets_tmp_checkout=$(mktemp -d); trap 'rm -rf $secrets_tmp_checkout' EXIT

subcommand=$1; shift
case "$subcommand" in
    init)
        subcmd_init "$@"
        ;;
    exec)
        subcmd_exec "$@"
        ;;
    edit)
        COMMIT_MSG="edit $*" subcmd_exec "$EDITOR" "$@"
        ;;
    vi)
        COMMIT_MSG="edit $*" subcmd_exec vi "$@"
        ;;
    generate)
        COMMIT_MSG="generate $*" subcmd_generate "$@"
        ;;
    inject)
        subcmd_inject "$@"
        ;;
    inject-to-dir)
        subcmd_inject_to_dir "$@"
        ;;
    slurp)
        subcmd_slurp "$@"
        ;;
    *)
        echo 1>&2 "subcommand '$subcommand' does not exist!"; exit 1;
        ;;
esac
